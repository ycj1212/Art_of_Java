# **Art_of_Java**

## **1. The Genius of Java**

큰 관점에서 역사는 프로그래밍의 역사에 의해 작은 규모로 미러링된다.
첫 사회는 간단한 시작으로부터 일어났듯이, 프로그래밍도 마찬가지다.
굉장한 문명이 일어나 번영하고 쇠퇴하듯이, 프로그래밍 언어도 마찬가지다.
그러나, 국가의 흥망성쇠를 통해 인류는 성장했다.
유사한 방식으로, 각각의 새로운 언어가 이전 언어를 대체하면서, 프로그래밍의 지속적인 개선이 진행되었다.
역사를 통해, 로마 제국의 멸망, 1066년에 영국의 침입, 또는 세계를 변화시킨 첫 핵 폭발, 과 같이, 중심이 되는 사건이 계속되었다.
비록 더 작은 규모일지라도, 공통점은 프로그래밍 언어와 일치하다.
예를 들면, FORTRAN의 발명은 컴퓨터가 프로그램되는 방법을 영원히 변화시켰다.
또 다른 중요한 사건은 자바의 탄생이였다.

자바는 프로그래밍의 인터넷 시대의 시작을 표시하는 이정표이다.
인터넷 연결이 있는 곳이라면 어디서든 실행할 수 있는 애플리케이션을 만들기 위해 특별히 설계된 자바의 "write once, run anywhere" 철학은 새로운 프로그래밍 패러다임을 정의했다.
Gosling이 처음으로 비교적 작은 종류의 문제의 해결책으로 봤던 것은 다음 세대의 프로그래머들을 위한 프로그래밍 지형을 정의하는 힘이 되었다.
자바는 근본적으로 우리가 프로그래밍에 대해 생각했던 방법을 바꾸어 컴퓨터 언어의 역사는 두 분류로 나눌 수 있다 : Before Java and After Java

Before Java 세계에서 프로그래머들은 stand-alone 머신을 실행하는 프로그램을 창조했다.
After Java 세계에서 프로그래머들은 높은 기여, 네트워크 환경을 위한 프로그램을 창조한다.
더 이상 프로그래머는 single computer에 관하여 생각하지 않는다.
대신에, 네트워크는 컴퓨터이고 오늘날 우리 프로그래머들은 서버, 클라이언트, 호스트에 관하여 생각한다.

비록 자바의 개발은 인터넷의 필요에 의해 움직였지만, 자바는 단순히 "인터넷 언어" 가 아니다.
오히려, 이것은 꽉 찬 특징, 일반적인 목적 프로그래밍 언어 현대에 설계된, 네트워크 세계
이것은 자바가 거의 모든 타입의 프로그래밍에 적절하다는 것을 의미한다.
때때로 네트워크의 능력에 의해 overshadowed되기도 하지만, 자바는 프로그래밍의 기술을 발전시킨 많은 혁신적인 기능을 통합했다.
이것의 혁신은 여전히 오늘날 computing을 통해 파급된다.
예를 들면, C#의 몇 가지 측면은 자바에 의해 처음 mainstreamed된 요소를 본떠 만들었다.

이 책을 통해 우리는 다양한 응용 분야에 적용함으로써 자바의 폭넓은 능력을 입증할 것이다.
일부 애플리케이션은 네트워킹 속성과는 무관하게 언어의 힘을 입증한다.
그들이 자바 문법과 설계 철학의 표현력을 보여주기 때문에 우리는 이것의 "pure code" 예시들을 호출한다.
다른 사람들은 자바 언어와 API 클래스를 사용하여 정교한 네트워크 프로그램이 개발될 수 있다는 용이성을 설명한다.
일괄적으로, 애플리케이션은 자바의 힘과 범위를 보여준다.

우리가 자바의 탐구를 시작하기 전에, 우리는 첫 장에서 그것을 주목할만한 프로그래밍 언어로 만드는 몇 가지 특징을 지적하기 위해 시간이 걸릴 것이다.
이들은 우리가 말하는 "genius of Java" 를 반영하는 특징이다.

### **Simple Types and Objects: The Right Balance**

객체 지향 컴퓨터 언어의 설계자가 직면하는 가장 큰 도전 중의 하나는 객체 대 단순형 딜레마를 다루는 방법이다.
여기 그 문제가 있다.
개념상으로 순수한 관점 포인트로부터, 모든 데이터 타입은 객체가 되어야 하고, 모든 타입은 보편적인 부모 객체로부터 내려와야 한다.
이것은 모든 데이터 타입이 상속 특성의 공통 set를 공유함으로서, 동일하게 동작하게 만든다.
그 문제는 int 또는 double과 같이, 간단한 타입을 객체로 만드는 것은 객체 메카니즘에 의해 발생하는 추가 overhead 때문에 성능 저하를 야기할 수 있다는 것이다.
간단한 타입이 루프와 조건문을 제어하는 데 종종 사용되기 때문에, 이 추가 overhead 는 광범위하고 부정적인 결과를 가질 것이다.
그 트릭은 "모든것은 객체이다"라는 욕구와 "performance counts"라는 현실 사이에서 올바른 균형을 찾는 것이다.

자바는 객체와 간단한 타입 문제를 우아한 방식으로 해결한다.
처음에, 그것은 8개의 간단한 타입을 정의한다: byte, short, int, long, char, float, double, and boolean.
이 타입들은 직접 2진수 값으로 번역된다.
그러므로, int 타입의 변수는 어떤 추가 overhead 없이 CPU에 의해 직접 연산될 수 있다.
자바에서 간단한 타입은 그들이 다른 언어에 있는 것과 마찬가지로 빠르고 효율적이다.
그러므로, int에 의해 제어되는 for 루프는 어떤 객체 관련 문제에도 영향을 받지 않고 최대 속도로 실행된다.

자바에서 간단한 타입 외에, 다른 모든 타입들은 보편적인 Object 슈퍼클래스를 상속받은 객체이다.
그러므로 다른 모든 타입은 상속 기능을 공유한다.
예를 들면, toString() 메소드가 Object에 의해 정의되기 때문에 모든 객체는 toString() 메소드를 가진다.

간단한 타입이 객체가 아니기 때문에, 자바는 객체와 비객체를 조금 다르게 다루는 것이 자유롭다.
이것은 실제 genius of Java의 설계가 드러나는 곳이다.
자바에서, 모든 객체는 간단한 타입의 경우와 마찬가지로, 직접적이 아니라, 참조를 통해 접근된다.
그러므로, 당신의 프로그램은 결코 객체에 직접 작용하지 않는다.
이 접근을 사용함으로써, 몇 가지 이점이 뒤따르는데, 가장 중요한 것은 garbage collection 이다.
모든 객체가 참조를 통해 접근되기 때문에 garbage collection은 효율적으로 구현될 수 있다: 객체에 대한 참조가 없을 때, 그것은 재활용 될 수 있다.
또 다른 이점은 Object 타입의 참조 객체가 시스템에서 어떤 객체를 참조할 수 있다는 것이다.

물론, 참조를 통해 모든 객체에 접근하는 것은 overhead를 추가된다.
그 이유는 참조가 본질적으로 주소(즉, 포인터)이기 때문이다.
그러므로, 모든 객체 접근은 주소를 통해 간접적으로 발생한다.
비록 현대 CPU가 간접적인 접근을 효율적으로 처리하지만, 간단한 타입의 경우와 같이 간접적인 접근은 데이터 자체에서 직접 작동하는 것만큼 빠르지 않다.

비록 간단한 타입이 꽤 효율적일지라도, 간단한 타입에 대응하는 객체가 필요한 경우도 있다.
예를 들면, 당신은 실행 중에 정수의 목록을 생성하고, 더 이상 필요없을 때 정수를 재활용할지도 모른다.
이러한 상황의 타입을 다루기 위해, 자바는 Integer와 Double과 같은 간단한 타입 wrapper를 정의한다.
이 wrapper는 간단한 타입이 필요할 때 객체 계층에 참가하는 것을 가능하게 한다.

자바의 객체 대 간단한 타입 문제의 해결책은 올바른 균형을 잡는다.
그것은 효율적인 프로그램이 쓰여지는 것을 허락하지만, 동시에 간단한 타입의 수행에 대해 부정적인 영향을 끼칠 걱정 없이 객체 모델이 구현되는 것을 허락한다.

### **Memory Management Through Garbage Collection**

메모리 관리 기술로서 쓰레기 수집은 긴 시간이 걸리지만, 자바에서 새 생명을 얻는다.
C++과 같은 언어에서, 프로그래머가 사용하지 않는 객체를 명시적으로 풀어줌으로써, 메모리는 수동적으로 관리되어야 한다.
이것은 더 이상 필요하지 않은 이후에 리소스를 풀어주는 것을 잊어버리거나 여전히 사용되는 리소스를 풀어주는 것을 잊어버리는 것은 흔하기 때문에 문제의 근원이다.
자바는 당신이 메모리를 관리함으로써 이 문제들을 막는다.
이것은 자바에서 모든 객체는 참조를 통해 접근되기 때문에 효율적인 방식이 될 수 있다.
그러므로, garbage collector가 참조가 없는 객체를 발견할 때, 그것은 객체가 사용되지 않고 재활용될 수 있다는 것을 안다.
자바가 직접적으로 객체를 직접적으로 연산될 수 있도록 허락했다면, 그렇게 garbage collection의 효율적인 수단은 불가능하게 될 것이다.

자바의 garbage collection의 사용은 일반적으로 자바의 철학을 반영한다.
자바 설계자


## **2. A Recursive-Descent Expression Parser

당신은 (10 - 5) * 3 과 같은 숫자 식을 포함하는 문자열을 입력하여 적절한 답을 계산하는 프로그램을 어떻게 작성하나요?
만약 프로그래머들 사이에 여전히 "high priesthood" 가 있다면, 이걸 하는 방법을 아는 사람은 거의 없을 것이다.
그렇지 않으면 많은 성취한 프로그래머들은 고수준 언어가 algebraic 식을 컴퓨터가 실행할 수 있는 명령어로 변환하는 방법에 의해 mystified된다.
이 과정은 expression parsing 이라 불리고, 모든 언어 컴파일러, 인터프리터, 스프레드시트 그리고 숫자 식을 컴퓨터가 사용할 수 있는 형식으로 변환을 필요로하는 다른 것의 backbone이다.

비록 uninitiated 에게는 신비롭지만, expression parsing은 우아한 해결책이 있는 잘 정의된 task이다.
이것은 그 문제가 잘 정의되어있고 expression parsing이 algebra의 엄격한 규칙에 따라 작동하기 때문이다.
이 챕터는 recursive-descent parser로서 공통으로 참조되어있는 것을 개발하고, 모두 필요한 지원은 당신이 숫자 식을 평가할 수 있게 루틴한다.
한때, 당신은 파서의 연산자를 마스터했고, 당신은 쉽게 향상할 수 있고 당신의 필요를 맞추기 위해 수정할 수 있다.

그 자체에서 유용한 코드 조각이 되는 것 외에는, 파서는 자바 언어의 힘과 범위를 설명하기 때문에 이 책의 첫 번째 예시로 채택되었다.
파서는 "pure code" subsystem 이다.
이것에 의해, 네트워크 기반이 아니고, GUI 인터페이스에 의존하지 않고, 애플릿이나 서블릿 등도 아니라는 것을 의미한다.
자바가 아니라, C나 C++코드에서 작성된 코드 타입이다.
자바는 우리가 인터넷을 프로그램하는 방법을 근본적으로 바꿨던 혁신적인 힘이기 때문에, 우리는 그 환경에 제한되지 않았다는 것을 때때로 잊어버린다.
대신에 자바는 다른 프로그래밍 task에 가깝게 적용될 수 있는 full-featured 언어이다.